# Android Task Hijacking

{{#include ../../banners/hacktricks-training.md}}

## Task, Back Stack and Foreground Activities

In Android, a **task** is essentially a set of activities that users interact with to complete a specific job, organized within a **back stack**. This stack orders activities based on when they were opened, with the most recent activity displayed at the top as the **foreground activity**. At any moment, only this activity is visible on the screen, making it part of the **foreground task**.

Here's a quick breakdown of activity transitions:

- **Activity 1** starts as the sole activity in the foreground.
- Launching **Activity 2** pushes **Activity 1** to the back stack, bringing **Activity 2** to the foreground.
- Starting **Activity 3** moves **Activity 1** and **Activity 2** further back in the stack, with **Activity 3** now in front.
- Closing **Activity 3** brings **Activity 2** back to the foreground, showcasing Android's streamlined task navigation mechanism.

![https://developer.android.com/images/fundamentals/diagram_backstack.png](<../../images/image (698).png>)

---

## Task affinity attacks

`taskAffinity` tells Android which task an `Activity` would *prefer* to belong to.  When two activities share the same affinity **Android is allowed to merge them inside the same back-stack even if they come from different APKs**.

If an attacker can place a malicious activity at the **root** of that stack, every time the victim opens the legitimate application the malicious UI will be the first thing the user sees – perfect for phishing or abusive permission requests.

The attack surface is wider than many developers think because **every activity automatically inherits an affinity equal to the application package name** (unless the developer sets `android:taskAffinity=""`).  Therefore *doing nothing* already leaves the app open to task hijacking on Android versions prior to 11.

### Classic "singleTask / StrandHogg" scenario

1. The attacker declares an activity with:
   ```xml
   <activity android:name=".EvilActivity"
             android:exported="true"
             android:taskAffinity="com.victim.package"
             android:launchMode="singleTask" >
       <intent-filter>
           <action android:name="android.intent.action.MAIN"/>
           <category android:name="android.intent.category.LAUNCHER"/>
       </intent-filter>
   </activity>
   ```
2. The malicious app is started once so that the task (with the spoofed affinity) exists in recent tasks.
3. When the user later opens the real application, Android finds there is already a task whose **root affinity matches the package** and just brings that task to the foreground.
4. The attacker’s UI is shown first.

### Default–Affinity (no `singleTask`) variant  – Caller ID case study

The vulnerability reported in the **Caller ID (caller.id.phone.number.block)** application shows that the attack *also* works against the default `standard` launch mode:

1. Attacker application creates a fake root activity and immediately hides itself:
   ```kotlin
   class HackActivity : AppCompatActivity() {
       override fun onCreate(savedInstanceState: Bundle?) {
           super.onCreate(savedInstanceState)
           moveTaskToBack(true)   // keep the task in recents but out of sight
       }
   }
   ```
2. The manifest only needs to copy the victim package into `taskAffinity`:
   ```xml
   <activity android:name=".HackActivity"
             android:exported="true"
             android:taskAffinity="com.caller.id.phone.number.block" >
       <intent-filter>
           <action android:name="android.intent.action.MAIN"/>
           <category android:name="android.intent.category.LAUNCHER"/>
       </intent-filter>
   </activity>
   ```
3. As soon as the user installs and opens the malicious app **once**, a task whose affinity equals the victim package exists (but sits in the background).
4. When the real Caller ID application is launched, Android re-uses that task and brings `HackActivity` to the foreground → phishing window/permission abuse.

> NOTE: Starting with **Android 11 (API 30)** the system does *not* place two packages that are not part of the same UID into the same task by default, mitigating this particular variant.  Older versions remain vulnerable.

---

## Detection & Exploitation checklist

1. Pull `AndroidManifest.xml` from the target APK and check that each `<activity>` (or the global `<application>` element) contains `android:taskAffinity=""` (empty) **or** a customised value.
2. If not, craft a malicious app:
   - `android:taskAffinity` = victim package name.
   - Provide a `MAIN/LAUNCHER` intent so the user can open it once.
   - Optionally call `moveTaskToBack(true)` to hide immediately.
3. Let the victim open their legitimate application → hijack.

## Mitigation

Developers should:

* Explicitly set `android:taskAffinity=""` at the `<application>` level (recommended) **or** give each activity a unique, private affinity.
* For highly sensitive screens, combine the above with `android:launchMode="singleInstance"` or modern [`setLaunchMode`](https://developer.android.com/reference/android/content/pm/ActivityInfo#launchMode) protections.
* Upgrade the app’s `targetSdkVersion` and enforce **Android 11** behavioural changes where tasks are not shared across packages by default.

---

## References

- [https://blog.dixitaditya.com/android-task-hijacking/](https://blog.dixitaditya.com/android-task-hijacking/)
- [https://blog.takemyhand.xyz/2021/02/android-task-hijacking-with.html](https://blog.takemyhand.xyz/2021/02/android-task-hijacking-with.html)
- [Android Manifest Misconfiguration Leading to Task Hijacking in Caller ID app](https://github.com/KMov-g/androidapps/blob/main/caller.id.phone.number.block.md)
- [https://medium.com/mobile-app-development-publication/the-risk-of-android-strandhogg-security-issue-and-how-it-can-be-mitigated-80d2ddb4af06](https://medium.com/mobile-app-development-publication/the-risk-of-android-strandhogg-security-issue-and-how-it-can-be-mitigated-80d2ddb4af06)

{{#include ../../banners/hacktricks-training.md}}
